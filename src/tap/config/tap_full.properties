##########################################################
#             FULL TAP CONFIGURATION FILE                #
#                                                        #
# TAP Version: 2.0                                       #
# Date: 18 Feb. 2015                                     #
# Author: Gregory Mantelet (ARI)                         #
#                                                        #
########################################################## 

###########
# GENERAL #
###########

# [OPTIONAL]
# This property lets set a custom home page.
# 
# 4 different kinds of value are accepted:
#     * nothing (default): the default home page provided by the library (just a simple HTML page displaying a list of all available TAP resources).
#     * name or relative path of a file: this method MUST be chosen if the new home page is a JSP file. This file MUST be inside the directory WebContent of your web application.
#     * a URI starting with file://: in this method the local file pointed by the URI will be merely returned when the home page will be requested.
#     * a URL: here, a redirection toward this URL will be made at each request on the home page
#     * a classpath: the classpath of an extension of tap.resource.HomePage which must replace the default home page resource.
#                    This class MUST have at least one constructor with exactly one parameter not NULL of type tap.resource.TAP.
home_page = 

# [OPTIONAL]
# MIME type of the service home page.
# 
# This property is used only if the specified "home_page" is a local file path (i.e. if "home_page=file://...").
# 
# If no value is provided "text/html" will be set by default.
# 
# Default: text/html
home_page_mime_type = 

############
# PROVIDER #
############

# [OPTIONAL]
# Name of the provider of the TAP Service.
provider_name = ARI

# [OPTIONAL]
# Description of the TAP Service.
tap_description = My TAP Service is so amazing! You should use it with your favorite TAP client.

############
# DATABASE #
############

# [MANDATORY]
# Method to use in order to create database connections.
# 
# Only two values are supported:
#     * jndi: database connections will be supplied by a Datasource whose the JNDI name must be given. This method may propose connection pooling in function of the datasource configuration.
#     * jdbc: the library will create itself connections when they will be needed thanks to the below JDBC parameters. This method does not propose any connection pooling.
# 
# Allowed values: jndi, jdbc.
database_access = 

# [MANDATORY]
# The translator to use in order to translate ADQL to a SQL compatible with the used DBMS and its spatial extension.
# 
# The TAP library supports only Postgresql (without spatial extension) and PgSphere for the moment. But you can provide your own SQL translator
# (even if it does not have spatial features), by providing a path to a class (within brackets: {...}) that implements ADQLTranslator (for instance: {apackage.MyADQLTranslator})
# and which have at least an empty constructor.
# 
# Allowed values: postgres, pgsphere, a class path
sql_translator = postgres

#############################
# IF DATABASE ACCESS = JNDI #
#############################

# [MANDATORY]
# JNDI name of the datasource pointing toward the database to use.
# It should be defined in the web application (e.g. in the META-INF/context.xml file in tomcat).
datasource_jndi_name = 

#############################
# IF DATABASE ACCESS = JDBC #
#############################

# [MANDATORY]
# JDBC driver URL pointing toward the database to use.
# 
# Note: The username, password or other parameters may be included in it, but in this case, the corresponding properties should leave empty or not provided at all.
jdbc_url =  

# [OPTIONAL]
# JDBC driver path.
# 
# By default, it is guessed in function of the database name provided in the jdbc_url property. It MUST be provided if another DBMS is used or if the JDBC driver path does not match the following ones:
#     * Oracle : oracle.jdbc.OracleDriver
#     * PostgreSQL: org.postgresql.Driver
#     * MySQL : com.mysql.jdbc.Driver
#     * SQLite : org.sqlite.JDBC
#jdbc_driver = 

# [MANDATORY]
# Mandatory if the username is not already provided in jdbc_url
# Username used to access to the database.
db_username = 

# [MANDATORY]
# Mandatory if the password is not already provided in jdbc_url
# Password used by db_username to access to the database.
# 
# Note: No password encryption can be done in this configuration file for the moment.
db_password = 

############
# METADATA #
############

# [MANDATORY]
# Metadata fetching method.
# 
# The value of this key defines the way the library will get the list of all schemas, tables and columns to publish and all their metadata (e.g. utype, description, type, ...).
# 
# In its current state, the library proposes two methods:
#    1/ Parse a TableSet XML document and load its content into the database schema TAP_SCHEMA (note: this schema is first erased and rebuilt by the library).
#    2/ Get all metadata from the database schema TAP_SCHEMA.
#  
# Allowed values: xml, db.
metadata =  

# [MANDATORY]
# Mandatory if the value of "metadata" is "xml".
# Local file path to the TableSet XML document. This XML must implement the schema TableSet defined by VODataService (http://www.ivoa.net/xml/VODataService/v1.1).
metadata_file = 

#########
# FILES #
#########

# [MANDATORY]
# Type of the file manager.
# 
# Accepted values are: local (to manage files on the local system). You can also add another way to manage files by providing
# the path (within brackets: {...}) to a class implementing TAPFileManager and having at least one constructor with only a
# java.util.Properties parameter.
# 
# Allowed values: local, a class path.
file_manager = local

# [MANDATORY]
# File path of the directory in which all TAP files (logs, errors, job results, backup, ...) must be.
file_root_path = 

# [OPTIONAL]
# Tells whether a directory should be created for each user.
# 
# If yes, the user directory will be named with the user ID. In this directory, there will be error files, job results and it may be the backup file of the user.
# 
# Allowed values: true (default), false.
directory_per_user = true

# [OPTIONAL]
# Tells whether user directories must be grouped.
# 
# If yes, directories are grouped by the first letter found in the user ID.
# 
# Allowed values: true (default), false.
group_user_dir = true

# [OPTIONAL]
# The default period (in seconds) to keep query results.
# 
# The prefix "default" means here that this value is put by default by the TAP Service if the client does not provide a value for it.
# 
# The default period MUST be less or equals to the maximum retention period. If this rule is not respected, the default retention period is set
# immediately to the maximum retention period.
# 
# A negative or null value means there is no restriction over the default retention period: job results will be kept forever. Float values are not allowed.
# 
# Default: 0 (results kept forever).
default_retention_period = 0

# [OPTIONAL]
# The maximum period (in seconds) to keep query results.
# 
# The prefix "max" means here that the client can not set a retention period greater than this one.
# 
# The maximum period MUST be greater or equals to the default retention period. If this rule is not respected, the default retention period is set
# immediately to the maximum retention period.
# 
# A negative or null value means there is no restriction over the maximum retention period: the job results will be kept forever. Float values are not allowed.
# 
# Default: 0 (results kept forever).
max_retention_period = 0

#############
# LOG FILES #
#############

# [OPTIONAL]
# Minimum level that a message must have in order to be logged.
#
# 5 possible values:
#     * DEBUG: every messages are logged.
#     * INFO: every messages EXCEPT DEBUG are logged.
#     * WARNING: every messages EXCEPT DEBUG and INFO are logged.
#     * ERROR: only ERROR and FATAL messages are logged.
#     * FATAL: only FATAL messages are logged.
#
# Default: DEBUG (every messages are logged)
min_log_level = 

# [OPTIONAL]
# Frequency of the log file rotation. That's to say, logs will be written in a new file after this period. This avoid having too big log files.
# Old log files are renamed so that highlighting its logging period.
# 
# The frequency string must respect the following syntax:
#     'D' hh mm: daily schedule at hh:mm
#     'W' dd hh mm: weekly schedule at the given day of the week (1:sunday, 2:monday, ..., 7:saturday) at hh:mm
#     'M' dd hh mm: monthly schedule at the given day of the month at hh:mm
#     'h' mm: hourly schedule at the given minute
#     'm': scheduled every minute (for completness :-))
# Where: hh = integer between 0 and 23, mm = integer between 0 and 59, dd (for 'W') = integer between 1 and 7 (1:sunday, 2:monday, ..., 7:saturday), dd (for 'M') = integer between 1 and 31.
# 
# Warning: The frequency type is case sensitive! Then you should particularly pay attention at the case when using the frequency types 'M' (monthly) and 'm' (every minute).
# 
# Note: this property is ignored if the file manager is not any more an extension of uws.service.file.LocalUWSFileManager.
# 
# Default: D 0 0 (daily at midnight)
log_rotation = 

##############
# UWS_BACKUP #
##############

# [OPTIONAL]
# Frequency at which the UWS service (that's to say, all its users and jobs) must be backuped.
# 
# Allowed values: never (no backup will never be done ; default), user_action (each time a user does a writing action, like creating or execution a job),
#                 a time (must be positive and not null) in milliseconds.
backup_frequency = never

# [OPTIONAL]
# Tells whether the backup must be one file for every user, or one file for each user.
# 
# This second option should be chosen if your TAP Service is organizing its files by user directories ; see the property directory_per_user.
# 
# Allowed values: user (one backup file for each user ; default), whole (one file for all users ; may generates a big file).
backup_mode = user

#####################
# ASYNCHRONOUS JOBS #
#####################

# [OPTIONAL]
# Maximum number of asynchronous jobs that can run simultaneously.
# 
# A negative or null value means there is no restriction over the number of running asynchronous jobs.
# 
# Default: there is no restriction => max_async_jobs=0.
max_async_jobs = 0

###################
# QUERY_EXECUTION #
###################

# [OPTIONAL]
# Default time (in milliseconds) for query execution.
# 
# The prefix "default" means here that the execution duration will be this one if the client does not set one.
# 
# The default duration MUST be less or equals to the maximum execution duration. If this rule is not respected, the default execution duration is set
# immediately to the maximum execution duration.
# 
# A negative or null value means there is no restriction over the default execution duration: the execution could never end. Float values are not allowed.
# 
# Default: there is no restriction => default_execution_duration=0.
default_execution_duration = 0

# [OPTIONAL]
# Maximum time (in milliseconds) for query execution.
# 
# The prefix "max" means here that the client can not set a time greater than this one.
# 
# The maximum duration MUST be greater or equals to the default execution duration. If this rule is not respected, the default execution duration is set
# immediately to the maximum execution duration.
# 
# A negative or null value means there is no restriction over the maximum execution duration: the execution could never end. Float values are not allowed.
# 
# Default: there is no restriction => max_execution_duration=0.
max_execution_duration = 0

##########
# OUTPUT #
##########

# [OPTIONAL]
# Comma separated list of output formats for query results.
# 
# Allowed values are: votable (or 'vot'), fits, text, csv, tsv, json and html.
# 
# The special value "ALL" will select all formats provided by the library.
# 
# The VOTable format may be more detailed with the following syntax: (serialization,version):mime_type:short_mime_type.
# The MIME type part and the parameters part may be omitted (e.g. votable:application/xml:votable , votable(td,1.3)]).
# Empty string values are allowed for each values (e.g. votable():: , votable(td)::votable).
# 
# It is also possible to define a custom Separated Value format, different from CSV and TSV, thanks to the following syntax: sv(separator):mime_type:short_mime_type.
# On the contrary to the VOTable syntax, the parameter (i.e. separator) MUST BE provided.
# The MIME type part may be omitted ; then the MIME type will be set by default to text/plain.
# 
# There is finally a last possible value: a classpath to a class implementing OutputFormat and having at least one constructor with exactly one parameter of type
# tap.ServiceConnection.
# 
# Default: ALL
output_add_formats = ALL

# [OPTIONAL]
# Default limit for the result output.
# 
# The prefix "default" means here that this value will be set if the client does not provide one.
# 
# This limit can be expressed in only one unit: rows.
# 
# A negative or null value means there is no restriction over this limit. Float values are not allowed.
# 
# Obviously this limit MUST be less or equal than output_max_limit.
# 
# Default: there is no restriction: output_default_limit=0
output_default_limit = 0

# [OPTIONAL]
# Maximum limit for the result output. The prefix "max" means here that the client can not set a limit greater than this one.
# 
# This limit can be expressed in only one unit: rows.
# 
# A negative or null value means there is no restriction over this limit. Float values are not allowed.
# 
# Obviously this limit MUST be greater or equal than output_default_limit.
# 
# Default: there is no restriction => output_max_limit=0
output_max_limit = 0

##########
# UPLOAD #
##########

# [OPTIONAL]
# Tells whether the Upload must be enabled.
# 
# If enabled, files can be uploaded in the file_root_path, the corresponding tables can be added inside the UPLOAD_SCHEMA
# of the database, queried and then deleted.
# 
# Allowed values: true (default), false.
upload_enabled = false

# [OPTIONAL]
# Default limit for the number of uploaded records that can be inserted inside the database.
# 
# The prefix "default" means here that this value will be set if the client does not provide one.
# 
# This limit can be expressed with 2 types: rows or bytes. For rows, you just have to suffix the value by a "r" (upper- or lower-case),
# with nothing (by default, nothing will mean "rows"). For bytes, you have to suffix the numeric value by "b", "kb", "Mb" or "Gb". Here,
# unit is case sensitive (except for the last character: "b"). No other storage unit is allowed.
# 
# A negative or null value means there is no restriction over this limit. Float values are not allowed.
# 
# Obviously this limit MUST be less or equal than upload_max_db_limit.
# 
# Default: there is no restriction: upload_default_db_limit=0
upload_default_db_limit = 0

# [OPTIONAL]
# Maximum limit for the number of uploaded records that can be inserted inside the database.
# 
# The prefix "max" means here that the client can not set a limit greater than this one.
# 
# This limit can be expressed with 2 types: rows or bytes. For rows, you just have to suffix the value by a "r" (upper- or lower-case),
# with nothing (by default, nothing will mean "rows"). For bytes, you have to suffix the numeric value by "b", "kb", "Mb" or "Gb". Here,
# unit is case sensitive (except for the last character: "b"). No other storage unit is allowed.
# 
# A negative or null value means there is no restriction over this limit. Float values are not allowed.
# 
# Obviously this limit MUST be greater or equal than upload_default_db_limit.
# 
# Default: there is no restriction: upload_max_db_limit=0
upload_max_db_limit = 0

# [OPTIONAL]
# Maximum allowed size for the uploaded file.
# 
# This limit MUST be expressed in bytes. Thus, you have to suffix the numeric value by "b", "kb", "Mb" or "Gb". Here, unit is case sensitive
# (except for the last character: "b"). No other storage unit is allowed.
# 
# A negative or null value means there is no restriction over this limit. Float values are not allowed.
# 
# In function of the chosen upload_max_db_limit type, upload_max_file_size should be greater in order to figure out the metadata part.
# 
# Default: there is no restriction => upload_max_file_size=0
upload_max_file_size = 0

#######################
# USER IDENTIFICATION #
#######################

# [OPTIONAL]
# Class to use in order to identify a user of the TAP service.
# 
# The same instance of this class will be used for every request sent to the service.
# 
# The value of this property MUST be a class path (with brackets: {...}) toward a class implementing the interface uws.service.UserIdentifier.
# This class MUST have one of its constructors with no parameter.
# 
# Default: no identification is performed => all users are then anonymous and their jobs can be seen by everybody.
user_identifier = 

##############
# GEOMETRIES #
##############

# [OPTIONAL]
# Comma-separated list of all allowed geometries.
# 
# Each item of the list must be the name (whatever is the case) of an ADQL geometrical function (e.g. INTERSECTS, COORDSYS, POINT) to allow.
# If the list is empty (no item), all functions are allowed. And if the special value NONE is given, no ADQL function will be allowed.
# 
# Default: all ADQL geometrical functions are allowed.
geometries = 

#################################
# USER DEFINED FUNCTIONS (UDFs) #
#################################

# [OPTIONAL]
# Comma-separated list of all allowed UDFs (User Defined Functions).
# 
# Each item of the list must have the following syntax: [fct_signature] or [fct_signature, classpath]. fct_function is the function signature.
# Its syntax is the same as in TAPRegExt. classpath is the path of a class extending UserDefinedFunction. An instance of this class will replace
# any reference of a UDF written in an ADQL function with the associated signature. A class path must be specified if the function to represent
# has a signature (and more particularly a name) different in ADQL and in SQL.
# 
# If the list is empty (no item), all unknown functions are forbidden. And if the special value ANY is given, any unknown function is allowed ;
# consequently the unknown ADQL functions will be translated into SQL as they are in ADQL.
# 
# Default: no unknown function is allowed.
udfs = 
